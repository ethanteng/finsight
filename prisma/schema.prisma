generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                  @id @default(cuid())
  email                  String                  @unique
  passwordHash           String
  tier                   String                  @default("starter")
  isActive               Boolean                 @default(true)
  emailVerified          Boolean                 @default(false)
  lastLoginAt            DateTime?
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  accessTokens           AccessToken[]
  accounts               Account[]
  conversations          Conversation[]
  privacySettings        PrivacySettings?
  syncStatuses           SyncStatus[]
  emailVerificationCodes EmailVerificationCode[]
  passwordResetTokens    PasswordResetToken[]
  profile                UserProfile?

  @@map("users")
}

model Account {
  id                  String        @id @default(cuid())
  plaidAccountId      String        @unique
  name                String
  type                String
  subtype             String?
  mask                String?
  officialName        String?
  currentBalance      Float?
  availableBalance    Float?
  currency            String?
  institution         String?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  lastSynced          DateTime?
  limit               Float?
  persistentAccountId String?
  verificationStatus  String?
  userId              String?
  user                User?         @relation(fields: [userId], references: [id])
  transactions        Transaction[]
}

model AccessToken {
  id            String    @id @default(cuid())
  token         String    @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  itemId        String?
  lastRefreshed DateTime?
  userId        String?
  user          User?     @relation(fields: [userId], references: [id])
}

model SyncStatus {
  id                 String    @id @default(cuid())
  lastSync           DateTime?
  accountsSynced     Int       @default(0)
  transactionsSynced Int       @default(0)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  userId             String?
  user               User?     @relation(fields: [userId], references: [id])
}

model Transaction {
  id                   String    @id @default(cuid())
  plaidTransactionId   String    @unique
  accountId            String
  amount               Float
  date                 DateTime
  name                 String
  category             String?
  pending              Boolean
  currency             String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  lastSynced           DateTime?
  authorizedDate       DateTime?
  categoryId           String?
  checkNumber          String?
  location             String?
  merchantName         String?
  originalDescription  String?
  paymentChannel       String?
  paymentMethod        String?
  pendingTransactionId String?
  account              Account   @relation(fields: [accountId], references: [id])
}

model Conversation {
  id                 String   @id @default(cuid())
  question           String
  answer             String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  anonymizedAnswer   String?
  anonymizedQuestion String?
  userId             String?
  user               User?    @relation(fields: [userId], references: [id])
  feedback           Feedback[]
}

model PrivacySettings {
  id                String   @id @default(cuid())
  allowDataStorage  Boolean  @default(true)
  allowAITraining   Boolean  @default(false)
  anonymizeData     Boolean  @default(true)
  dataRetentionDays Int      @default(30)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id])
}

model DemoSession {
  id            String             @id @default(cuid())
  sessionId     String             @unique
  userAgent     String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  conversations DemoConversation[]
}

model DemoConversation {
  id        String      @id @default(cuid())
  question  String
  answer    String
  sessionId String
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  session   DemoSession @relation(fields: [sessionId], references: [id])
  feedback  Feedback[]
}

model UserProfile {
  id                     String                  @id @default(cuid())
  email                  String                  @unique
  profileHash            String                  @unique
  lastActive             DateTime?
  conversationCount      Int                     @default(0)
  isActive               Boolean                 @default(true)
  profileDeleted         Boolean                 @default(false)
  userId                 String?                 @unique
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  profileText            String                  @default("")
  lastUpdated            DateTime                @default(now())
  encrypted_profile_data encrypted_profile_data?
  user                   User?                   @relation(fields: [userId], references: [id])

  @@map("user_profiles")
}

model encrypted_profile_data {
  id            String      @id
  profileHash   String      @unique
  encryptedData String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime
  user_profiles UserProfile @relation(fields: [profileHash], references: [profileHash])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
}

model EmailVerificationCode {
  id        String   @id @default(cuid())
  code      String   @unique
  userId    String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_verification_codes")
}

model MarketNewsContext {
  id             String              @id @default(cuid())
  contextText    String
  rawData        Json?
  lastUpdate     DateTime            @updatedAt
  createdAt      DateTime            @default(now())
  dataSources    String[]
  keyEvents      String[]
  availableTiers String[]
  isActive       Boolean             @default(true)
  manualOverride Boolean             @default(false)
  lastEditedBy   String?
  history        MarketNewsHistory[]

  @@map("market_news_context")
}

model MarketNewsHistory {
  id           String            @id @default(cuid())
  contextId    String
  contextText  String
  dataSources  String[]
  keyEvents    String[]
  changeType   String
  changeReason String?
  changedBy    String?
  createdAt    DateTime          @default(now())
  context      MarketNewsContext @relation(fields: [contextId], references: [id])

  @@map("market_news_history")
}

model Feedback {
  id        String   @id @default(cuid())
  score     Int      // 1-5 rating
  createdAt DateTime @default(now())
  
  // Optional relationships - only one will be set
  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id])
  
  demoConversationId String?
  demoConversation   DemoConversation? @relation(fields: [demoConversationId], references: [id])
  
  @@map("feedback")
}
